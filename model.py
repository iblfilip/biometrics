import cv2
import numpy as np
import matplotlib.pyplot as plt
from sklearn.preprocessing import minmax_scale
from sklearn.metrics import pairwise_distances

import plots
import utils

PREPROCESS_PATH = 'preprocessed'


def sum_ranks(rank_dict, n_ranks):
    """
    Sum number of occurrences of each rank
    :param rank_dict: dictionary with rank of match for each classified image
    :param n_ranks: total number of ranks
    :return: rank_sums: sums for each rank
    """
    rank_sums = {}
    for i in range(n_ranks):
        summed = sum(value == i for value in rank_dict.values())
        rank_sums[i] = summed
    return rank_sums


def get_rank(sorted_scores, label_test):
    """
    Get rank of match images
    :param sorted_scores: list of sorted labels and scores sorted from the best results
    :param label_test: label of test image
    :return: rank: rank where test label is equal to train label
    """
    rank = next(i for i, item in enumerate(sorted_scores) if item[1] == label_test)
    return rank


def scale_matrix(matrix):
    """
    scale matrix between 0 and 1
    :param matrix: numpy matrix to scale
    :return: scaled matrix
    """

    np_matrix = np.asarray(matrix, dtype=float)
    return minmax_scale(np_matrix, feature_range=(0, 1), axis=1)


def extract_contours(imgs, show_contour=False):
    """
    extract contours from images. Sort contours by contour area and return biggest contour foreach image
    :param imgs: list of images
    :return: cnt_list: list of contours
    """

    cnt_list = []
    for i, img in enumerate(imgs):
        # invert colors in image
        img_inv = abs(img - 255)
        contours, hierarchy = cv2.findContours(img_inv, cv2.RETR_LIST, cv2.CHAIN_APPROX_SIMPLE)

        sorted_contours = sorted(contours, key=cv2.contourArea, reverse=True)
        cnt = sorted_contours[0]
        cnt_list.append(cnt)

        if show_contour:
            utils.show_contour(img, cnt)

    return cnt_list


def extract_SURF(img, toGray=False, show_image=False):
    """
    Extract and return keypoints and descriptors with SURF descriptor.
    :param img: image
    :return: kp: keypoints, des: descriptor
    """

    if toGray is not False:
        img = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)

    # param hessian threshold - to limit number of features
    surf = cv2.xfeatures2d.SURF_create(100)
    kp, des = surf.detectAndCompute(img, None)

    if show_image is not False:
        img2 = cv2.drawKeypoints(img, kp, None, (255, 0, 0), 4)
        plt.imshow(img2), plt.show()

    return kp, des


def extract_SURF_features(imgs):
    """
    For each image call extract_SURF function and append results to keypoints and descriptors dictionaries.
    :param imgs: list of images
    :return: kp_dict: keypoints dict, des_dict: descriptor dictionary
    """

    kp_list = []
    des_list = []
    for i, img in enumerate(imgs):
        kp, des = extract_SURF(img)
        kp_list.append(kp)
        des_list.append(des)
    return kp_list, des_list


def match_SURF(imgs_train, imgs_test, labels_train, labels_test, kps_train, kps_test, deses_train,
               deses_test, show_img=False):
    """
    Match test and train SURF features and calculate distance_matrix, corresponding label_matrix and ranks
    based on accuracy.
    :param imgs_train: array of train images
    :param imgs_test: array of test images
    :param labels_train: corresponding labels to cnts_train
    :param labels_test: corresponding  labels to cnts_test
    :param kps_train: train key points generated by SURF
    :param kps_test: test key points generated by SURF
    :param deses_train: train SURF descriptors
    :param deses_test: test SURF descriptors
    :param show_img: mark if print images comparison
    :return scores_all: matrix with distances for all train/test pairs
    :return labels_all: corresponding matrix to scores_all with labels
    :return: rank_sums: sums of matches for each rank
    """

    bf = cv2.BFMatcher()
    rank_dict = {}
    scores_all = np.empty((0, 44), int)
    labels_all = np.empty((0, 44), str)

    for i_test, (img_test, kp_test, des_test, label_test) in enumerate(
            zip(imgs_test, kps_test, deses_test, labels_test)):
        profile_test = utils.get_shape_type(label_test)
        scores = []
        labels = []
        goods = []
        for i_train, (kp_train, des_train, label_train) in enumerate(zip(kps_train, deses_train, labels_train)):
            profile_train = utils.get_shape_type(label_train)
            if profile_test == profile_train:
                matches = bf.knnMatch(des_train, des_test, k=2)

                good = []
                for m, n in matches:
                    if m.distance < 0.55 * n.distance:
                        good.append([m])

                scores.append(len(good))
                labels.append(label_train)
                goods.append(good)

        sorted_scores = sorted(zip(scores, labels), reverse=True)

        if show_img:
            best_train_i = labels_train.index(sorted_scores[0][1])
            best_train_i2 = labels.index(sorted_scores[0][1])
            img3 = cv2.drawMatchesKnn(imgs_train[best_train_i], kps_train[best_train_i], img_test, kp_test,
                                      goods[best_train_i2], None)
            plt.imshow(img3), plt.title(sorted_scores[0][1] + ' training - ' + label_test + ' test' + ' (' + str(
                sorted_scores[0][0]) + ')'), plt.show()

        rank = get_rank(sorted_scores, label_test)
        rank_dict[label_test] = rank
        scores_all = np.append(scores_all, [scores], axis=0)
        labels_all = np.append(labels_all, [labels], axis=0)

    rank_sums = sum_ranks(rank_dict, scores_all.shape[1])
    return scores_all, labels_all, rank_sums


def match_contours(cnts_train, cnts_test, labels_train, labels_test, measure_height=False):
    """
        Match test and train contours and calculate distance_matrix, corresponding label_matrix and ranks
        based on accuracy. If measure_height==True - measure similarity based on height of contours, otherwise do
        matchShape()
        :param cnts_train: contours array for train images
        :param cnts_test: contours array for test images
        :param labels_train: corresponding labels to cnts_train
        :param labels_test: corresponding  labels to cnts_test
        :param measure_height: mark
        :return scores_all: matrix with distances for all train/test pairs
        :return labels_all: corresponding matrix to scores_all with labels
        :return: rank_sums: sums of matches for each rank
    """
    rank_dict = {}
    scores_all = np.empty((0, 44), float)
    labels_all = np.empty((0, 44), str)
    for i_test, (cnt_test, label_test) in enumerate(zip(cnts_test, labels_test)):

        # get mark if test img is shot from profile or front side
        profile_test = utils.get_shape_type(label_test)

        scores = []
        labels = []
        if measure_height:
            _, _, _, h_test = cv2.boundingRect(cnt_test)

        for i_train, (cnt_train, label_train) in enumerate(zip(cnts_train, labels_train)):
            profile_train = utils.get_shape_type(label_train)
            if profile_test == profile_train:
                labels.append(label_train)

                if measure_height:
                    _, _, _, h_train = cv2.boundingRect(cnt_train)
                    dist = pairwise_distances([[h_train]], [[h_test]], metric="euclidean")
                    scores.append(dist[0, 0])
                else:
                    similarity = cv2.matchShapes(cnt_test, cnt_train, 1, 0.0)
                    scores.append(similarity)

        sorted_scores = sorted(zip(scores, labels))
        rank = get_rank(sorted_scores, label_test)
        rank_dict[label_test] = rank
        scores_all = np.append(scores_all, [scores], axis=0)
        labels_all = np.append(labels_all, [labels], axis=0)

    rank_sums = sum_ranks(rank_dict, scores_all.shape[1])
    return scores_all, labels_all, rank_sums


def classify_by_SURF(img_src, show_img=False):
    print('\nClassifying {} images with SURF'.format(img_src))

    imgs_train, labels_train = utils.load_images(img_src, 'training', to_gray=True)
    imgs_test, labels_test = utils.load_images(img_src, 'test', to_gray=True)
    print(' Images loaded ')

    kp_train, des_train = extract_SURF_features(imgs_train)
    kp_test, des_test = extract_SURF_features(imgs_test)
    print(' Features extracted ')

    print(' Matching SURF features and doing classification ')
    np_scores, np_labels, rank_sums_list = match_SURF(imgs_train, imgs_test, labels_train, labels_test, kp_train,
                                                      kp_test, des_train, des_test, show_img)
    return np_scores, np_labels, rank_sums_list


def classify_by_contours(img_src, measure_height=False):
    if measure_height:
        print('\nClassifying {} images with contour height'.format(img_src))
    else:
        print('\nClassifying {} images with contours match'.format(img_src))

    img_train, labels_train = utils.load_images(img_src, 'training', to_gray=True)
    img_test, labels_test = utils.load_images(img_src, 'test', to_gray=True)
    print(' Images loaded ')

    cnt_train = extract_contours(img_train)
    cnt_test = extract_contours(img_test)
    print(' Features extracted ')

    print(' Matching features and doing classification ')
    np_scores, np_labels, rank_sums_list = \
        match_contours(cnt_train, cnt_test, labels_train, labels_test,
                       measure_height=True) if measure_height else match_contours(cnt_train, cnt_test, labels_train,
                                                                                  labels_test)
    return np_scores, np_labels, labels_test, rank_sums_list


def combine_classification(score_cont_matrix, score_cont_h_matrix, score_surf_matrix, score_surf_h_matrix,
                           labels_matrix, labels_test):
    """
    Classifier which combines results of all classifiers
    :param score_cont_matrix: result matrix of contour body classification
    :param score_cont_h_matrix: result matrix of contour head classification
    :param score_surf_matrix: result matrix of SURF body classification
    :param score_surf_h_matrix: result matrix of SURF head classification
    :param labels_matrix: corresponding matrix with labels for previous matrices
    :param labels_test: array with test labels
    :return dist_matrix: distance matrix for overall classification
    :return scores_dict: dictionary with scores
    :return ranks_overall: dictionary with counts for each rank
    """

    # rescale matrices where needed to have values in range <0,1>
    scaled_cont_matrix = scale_matrix(score_cont_matrix)
    scaled_surf_matrix = scale_matrix(score_surf_matrix)
    scaled_surf_h_matrix = scale_matrix(score_surf_h_matrix)

    n_ranks = labels_matrix.shape[1]

    rank_dict = {}
    scores_dict = {}
    dist_matrix = np.empty((0, 44), float)

    for i_test, (surf_test, surf_h_test, cont_test, cont_h_test, label_test) in enumerate(
            zip(scaled_surf_matrix, scaled_surf_h_matrix, score_cont_h_matrix, scaled_cont_matrix, labels_test)):

        distances = []

        for surf_train, surf_h_train, cont_train, cont_h_train, label_train in zip(surf_test, surf_h_test, cont_test,
                                                                                   cont_h_test,
                                                                                   labels_matrix[i_test]):
            # revert surf scores to get distance like metric
            surf_h_reverted = 1 - surf_h_train
            surf_reverted = 1 - surf_train
            # calculate average distance from all four distances
            distance_avg = (surf_h_reverted + cont_train + surf_reverted + cont_h_train) / 4
            distances.append(distance_avg)

        dist_matrix = np.append(dist_matrix, [distances], axis=0)
        sorted_scores = sorted(zip(distances, labels_matrix[i_test]))
        # add score to score_dict, check if check is True Positive or False positive
        scores_dict[utils.create_label(label_test, sorted_scores[0][1])] = sorted_scores[0][0]

        # calculate rank of match, if 0 then matched at first rank
        rank = next(i for i, item in enumerate(sorted_scores) if item[1] == label_test)
        rank_dict[label_test] = rank

    ranks_overall = sum_ranks(rank_dict, n_ranks)
    return dist_matrix, scores_dict, ranks_overall


def main():
    print('OpenCV version {}'.format(cv2.__version__))
    print('Starting classification')
    # run 4 distinct classifiers, get results
    score_cont_matrix, _, _, ranks_cont_h = classify_by_contours(  PREPROCESS_PATH +'/masked_body', measure_height=True)
    score_cont_h_matrix, labels_matrix, labels_test, rank_cont_sums = classify_by_contours('preprocessed/masked_head')
    score_surf_matrix, _, ranks_surf = classify_by_SURF( PREPROCESS_PATH + '/body', show_img=False)
    score_surf_h_matrix, _, ranks_surf_h = classify_by_SURF(PREPROCESS_PATH + '/masked_head', show_img=False)

    print('\nDoing combined classification')
    # run classifier which combines results of all classifiers
    dist_matrix, scores_dict, ranks_overall = \
        combine_classification(score_cont_matrix, score_cont_h_matrix, score_surf_matrix, score_surf_h_matrix,
                               labels_matrix, labels_test)

    n_ranks = labels_matrix.shape[1]
    n_predictions = labels_matrix.shape[0]

    # print accuracies for all classifiers
    print('Printing classification results')
    utils.print_accuracy(ranks_cont_h, n_predictions, 'Contours')
    utils.print_accuracy(rank_cont_sums, n_predictions, 'Contours head')
    utils.print_accuracy(ranks_surf, n_predictions, 'SURF body')
    utils.print_accuracy(ranks_surf_h, n_predictions, 'SURF head mask')
    utils.print_accuracy(ranks_overall, n_predictions, 'Combined')

    # add all ranks to dict to use it to plot CMC
    sums = {'Contours': ranks_cont_h, 'Contours head': rank_cont_sums, 'SURF': ranks_surf,
            'SURF head': ranks_surf_h, 'Combined': ranks_overall}

    # plot all required plots
    print('\nPlotting graphs')
    plots.plot_ICH(dist_matrix, labels_matrix, labels_test)
    plots.plot_CMC(sums, n_ranks, n_predictions)
    plots.plot_EER(scores_dict)

    print('Classification finished')


if __name__ == "__main__":
    main()
